# TODO


- [ ] add default None for methods after generating rust version. 
- [ ] Add all exceptions at the authzee level
- [ ] multiprocess compute - multiple modes
    - simple 
        - Every request just gets sent to a process in a pool and all compute is done in that single process
    - legacy
        - All work is offloaded to a process pool but the main process controls all of it
        - A complex request process would be expected to do this work
    - complex
        - 2 pools of processes.  One for handling requests and one for workers. If you only have one pool you may get into deadlock where you have requests taking all of the processes
        - For single page eval it only uses a request handling process
        - For multi-page eval it will use worker processes as well
        - For authorization it will use a request process and many worker processes.
            - serial paging should be able to chain worker processes, either by returning in the next page ref to the request process or by a worker submitting another task to the pool
                - This can basically be a dupe of the legacy setup because that works really well
            - Parallel paging should send out a page of pages at a time until all pages are sent then wait for a response 

- [ ] Storage for SQL
    - Parallel paging the uses limit paging
        - faster because it's parallel but for a lot of pages may actually be slower
    - single paging that uses id pages

- [ ] Distributed compute with redis

- [x] For storage that is in the process, we have to copy it from authzee to the compute module
    - In authzee start do we just set `self._compute._storage = self._storage` 
    - or do we pass it in the the start method as an option to the compute engine?
        - Thi is probably the smarter way, since compute can not pass it around as usual if it has any start sections that pass around the storage module?
    - **SOLUTION** - Or for storage we require that you pass in the dictionary where you want to store it as an arg, then that is just passed along like a pointer to all other storage modules that are created.
- [x] should break up the core authorize steps into separate functions to make it easier for the compute to reuse it.
    - Authorize_deny to evaluate deny grants
    - authorize_allow to evaluate allow grants and 
    - should need to separate allow or deny as the function is unique to that, and should assume that the action matches as well. Besides that the authorization function is nicely reusable. 
    - **SOLUTION** - maybe later it's not that bad now. 
- [x] Should authorize return errors as well? 
    - It's not really scalable to do that. 
    - With audit it's done a page or few at a time because they could all be errors. 
    - Authorize should only return whether it is authorized or not and the reason.  
    - Should be scalable and optimized around the decision, not the errors. 
    - It should only return whatever the critical error it was that caused it to fail. 
    - Can still return the same response but it should only be the list of critical errors. S
- [x] optionally check output schemas
    - **SOLUTION** - this should just be in tests. 
- [x] default for parallel paging should check storage if compatible
- [x] How to return errors?
    - Not really a unified way to do this... 
    - Could just be at least standard for different errors. 
    - how to handle for different workflows
    - Maybe this should only include the errors for the workflow exceptions? 
    - The other part of the workflow was just so it returned a schema response.
    - **SOLUTION** - make it standard the all spec errors return the errors fields, and exceptions are raised at the authzee level.
- [x] next_page_ref in audit page
- [x] Run a full audit in the background and store results?
    - Probably should just leave this to the client to manage, unless storage is going to need to facilitate this as well
    - Either way it will have to be paginated since they can't really retrieve all of the results at once
    - **Solution** - not now
- [x] compute should clean up latches? 
    - storage should just paginate latches it's up to compute to clean up failed latches. 
    - **solution** - no just do it with storage.  should paginate behind the scenes as needed.
- [x] store grants with UUID as str in InMemoryDB
    - probably should be it's all stored as string and whatnot
    - or I could index by UUID and then just store grant as a string
    - **SOLUTION** - grants get a string but the lookup is UUID.  Should be a list because that only speeds up repeal and get by UUID. 